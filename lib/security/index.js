const { signJWT } = require('./jwt')

async function parseSecurity (oasSecuritySchemes, securityRequirements, securityOptions) {
  const headers = {}
  const queries = {}

  // We only need to set these values if there are security schemes defined within the OAS
  if (oasSecuritySchemes) {
    // For each required security mechanism
    for await (const key of Object.keys(securityRequirements)) {
      const securityScheme = oasSecuritySchemes[key]

      // Security scheme is not defined in the global scheme, throw error
      if (!securityScheme) {
        throw new Error(`Security scheme ${key} not defined in spec.`)
      }

      const { secret, jwt } = securityOptions

      /**
       * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#security-scheme-object
       *
       * REQUIRED. The type of the security scheme. Valid values are "apiKey", "http", "oauth2", "openIdConnect".
       *
       * Only apiKey and http options are implemented here
       */
      switch (securityScheme.type) {
        // http type
        case 'http':
          if (!headers.authorization) {
            headers.authorization = []
          }
          /**
           * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#security-scheme-object
           *
           * REQUIRED. The name of the HTTP Authorization scheme to be used in the Authorization header as defined in RFC7235.
           * The values used SHOULD be registered in the IANA Authentication Scheme registry.
           *
           * https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml
           *
           * Only bearer is implemented here
           */
          switch (securityScheme.scheme) {
            case 'bearer':
              /**
               * A hint to the client to identify how the bearer token is formatted. Bearer tokens are usually
               * generated by an authorization server, so this information is primarily for documentation purposes.
               *
               * Only the JWT mechanism is used here, otherwise, the token is just a plain value
               */
              switch (securityScheme.bearerFormat) {
                case 'JWT': {
                  const { exp } = jwt || {}
                  const jwtOptions = {}
                  if (exp) {
                    jwtOptions.expiresIn = exp
                  }

                  headers.authorization.push(`Bearer ${await signJWT({}, secret, jwtOptions)}`)
                  break
                }
                default:
                  headers.authorization.push(`Bearer ${secret}`)
              }
              break
            default:
              throw new Error(`${securityScheme.scheme} scheme type not implemented.`)
          }
          break // break http

        // apiKey type
        case 'apiKey':
          /**
           * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#security-scheme-object
           *
           * REQUIRED. The location of the API key. Valid values are "query", "header" or "cookie".
           *
           * Only query and header
           */
          switch (securityScheme.in) {
            case 'header':
              if (!headers[securityScheme.name]) {
                headers[securityScheme.name] = []
              }
              headers[securityScheme.name].push(secret)
              break
            case 'query':
              if (!queries[securityScheme.name]) {
                queries[securityScheme.name] = []
              }
              queries[securityScheme.name].push(secret)
              break
            case 'cookie':
              throw new Error('cookie in type not implemented.')
          }
          break // break apiKey

        default:
          throw new Error(`${securityScheme.type} type not implemented.`)
      }
    }
  }

  return {
    headers,
    queries
  }
}

module.exports = { parseSecurity }
